#include "masterNodeLib.h"
std::unordered_map<std::string, std::vector<std::string>> electedMasterNodes; // Keeps track of which master nodes were elected for which timestamps. For bookkeeping only.
std::string nextVotingTimestampStr; // Used to hold the epoch at which the next voting round will begin. Master nodes should sign this string.
std::string blockStorageNode = ""; // The ID of the storage node to send closed blocks to.
std::string stateChangeStorageNode = ""; // The storage node used for state changes.
std::string base64encodedKey = ""; // Holds the base-64 encoded public key of this node so we don't have to keep recomputing it in timeToCloseBlock
bool ignoreThisVotingRound;
bool subscribedTo21;
time_t openVotingStartMinute = 55;
TransactionsMap transactions;//(0, [](const Transaction& tx) { return std::hash<std::string>()(tx.getTxId()); });
BlocksMap blocks;
std::vector<Voter> randomNumbers; // Used to store random numbers generated by master nodes in new voting process.
std::vector<Voter> blockProducers; // The nodes that are eligible to be block producers in this round, sorted.
std::vector<Transaction> queueOut; // Used to store the transactions that should be committed to the next block.
bool inVotingPhase; // True if voting has begun.
Voter chosenNumber; // A struct to hold the random number generated by this node at the start of a new voting phase, based on the signature of the voting timestamp.
WebSocketServer wsServer;
SUB_TYPE master21;
dht::crypto::Identity* nodeIdentity = nullptr;
time_t lastRoundTimestamp;
time_t lastCleanupTime;
std::mutex transactionsMutex;
std::mutex randomNumbersMutex;
std::atomic<bool> requestedMasterNodeStop = false; // Used to signal to the master node loop to exit.
std::atomic<bool> runningMasterNode = false; // Whether or not the master node loop is running.
void runLoop() {
	try {
		time_t now = 0;
		runningMasterNode = true;
		while (true) {
			if (requestedMasterNodeStop)
				break;
			now = getCurrentTimestamp();
			enterAndExitVotingPhase();
			time_t timeSinceLastRound = now - lastRoundTimestamp;
			if (timeSinceLastRound >= 1) {
				lastRoundTimestamp = now;
				timeToCloseBlock();
			}
			time_t timeSinceCleanup = now - lastCleanupTime;
			if (timeSinceCleanup > 60*5) {
				lastCleanupTime = now;
				cleanupTransactionsMap();
			}
			std::this_thread::sleep_for(std::chrono::nanoseconds(60));
		}
		runningMasterNode = false;
	} catch (...) {
		runningMasterNode = false;
		throw;
	}
}

uint8_t generateSecureRandomDigit(bool includeZero) {
	// If this is the first digit, we shouldn't include 0 or boost::multiprecision will fail to create an integer.
	NumberDistribution distribution((includeZero) ? '0' : '1', '9');
	RandomNumberGenerator generator{ dht::crypto::random_device{}() };
	Generator numberGenerator(generator, distribution);
	return static_cast<uint8_t>(numberGenerator());
}

int getBlockProducerFor(time_t timestamp) {
	if (blockProducers.size() < 1)
		return -1;
	return static_cast<int>(getSecondsPastHour(timestamp) % blockProducers.size());
}

int getCurrentBlockProducer() {
	if (blockProducers.size() < 2)
		return -1;
	return static_cast<int>(getSecondsPastHour() % blockProducers.size());
}

bool isBlockProducer() {
	int currentBlockProducer = getCurrentBlockProducer(); // Returns -1 if no block producers are available.
	if (currentBlockProducer < 0)
		return false;
	return blockProducers.at(currentBlockProducer).publicKey == dhtNode.getId().toString();
}

bool inVotingTime() {
	// The timestamp has already been refreshed by the outer forever loop.
	time_t minutes = getSecondsPastHour() / 60;
	return minutes >= openVotingStartMinute;
}

void enterAndExitVotingPhase() {
	if (inVotingTime()) {
		if (!inVotingPhase) { // This is the first time we've entered this voting phase.
			inVotingPhase = true;
			logDebug("Voting now open");
			if (canParticipateInVoting()) {
				std::string signature(createX509Signature(nextVotingTimestampStr, nodeIdentity));
				uint32_t number = 0;
				size_t n = signature.length();
				for (int i = 0; i < n; i++)
					number += signature[i];
				chosenNumber = Voter(signature, dhtNode.getId().toString(), number, true);
				{
					std::lock_guard<std::mutex> lock(randomNumbersMutex);
					randomNumbers.push_back(chosenNumber);
				}
				gossip("masternodes", CommandType::choseRandomNumber, { {"s", signature}, {"key", base64_encodeString(nodeIdentity->first->getPublicKey().toString())} });
			}
		}
	} else { // If the voting interval has expired
		if (inVotingPhase) {
			logDebug("Voting now closed");
			inVotingPhase = false;
			// Set the next voting timestamp to the minute mark in the hour when voting will start.
			updateNextVotingTimestamp();
			blockProducers.clear();
			// Next, the 21 lowest random numbers will be master nodes 0 to 20. We'll start with the block producer being position 0.
			bool nodeInList = false;
			// randomNumbers could be 0 if this node was not allowed to participate in this round of voting due to canParticipateInVoting.
			// It will be 1 if this node is the only one that cast a ballot, and we don't want this node to vote itself in.
			if (randomNumbers.size() > 1) {
				std::sort(randomNumbers.begin(), randomNumbers.end(), [](const Voter&a, const Voter&b) {
					return a < b;
				});
				for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
					if (it->valid) { // If we computed a valid number on this Voter
						if (it->publicKey == dhtNode.getId().toString())
							nodeInList = true;
						blockProducers.push_back(Voter(*it));
					}
					if (blockProducers.size() == TOTAL_MASTER_NODES)
						break;
				}
				randomNumbers.clear();
				std::vector<Voter>().swap(randomNumbers); // Deallocate memory since we won't need it for another hour.
				electedMasterNodes[nextVotingTimestampStr] = std::vector<std::string>();
				for (std::vector<Voter>::iterator it = blockProducers.begin(); it != blockProducers.end(); it++)
					electedMasterNodes[nextVotingTimestampStr].push_back(it->publicKey);
				json j = electedMasterNodes;
				const char* jsonDump = j.dump().c_str();
				std::ofstream outFile("masternodes.dat", std::ios::out | std::ios::binary);
				outFile.write(jsonDump, strlen(jsonDump));
				outFile.close();
			} // If there were voters in this round.
			if (nodeInList) {
				if (!subscribedTo21) {
					// If this master node is not on the master21 channel already, meaning that before this round they were not among the 21.
					// Listen on the channel reserved for the 21 master nodes.
					logDebug("Subscribed to 21");
					master21 = subscribeTo("master21");
					subscribedTo21 = true;
				}
			} else { // If node not in list
				if (subscribedTo21) { // If this master node is subscribed.
					logDebug("Unsubscribed from 21");
					unsubscribeFrom(master21);
					subscribedTo21 = false;
				}
			} // If !nodeInList
			// The ignore flag should have affect for one interval only. Now that this interval has elapsed, this node is allowed to vote in the upcoming interval.
			ignoreThisVotingRound = false;
		} // If inVotingPhase
	} // If !inVotingTime
}

bool compareTransactions(const Transaction& lhs, const Transaction& rhs) {
	return lhs.getTimeStamp() < rhs.getTimeStamp();
}

void timeToCloseBlock() {
	// The list of transactions to commit to the block is stored in queueOut.
	// A random storage node will commit the transactions to the block.
	if (base64encodedKey.empty())
		base64encodedKey = base64_encodeString(nodeIdentity->first->getPublicKey().toString());
	std::vector<Transaction> tempvect;
	// QueueOut is modified when a transaction reaches verification, and
	// timeToCloseBlock runs on the main loop. So we need to protect this resource.
	{ // Critical section
		std::lock_guard<std::mutex> lock(transactionsMutex);
		std::sort(queueOut.begin(), queueOut.end(), compareTransactions); // Sort the transactions by timestamp.
		//compare transaction time with current time
		//if any transaction times exceed current time keep those transaction in queueOut
		std::vector<Transaction>::iterator it = queueOut.begin();
		while (it != queueOut.end()) {
			if (it->getTimeStamp() <= currentTimestamp) {
				tempvect.push_back(*it);
				it = queueOut.erase(it);
			} else {
				break;
			}
		}
	}
	//create block by passing list of transactions msg
	BlockUtil::Block block = BlockUtil::getBlock(std::move(tempvect));
	//if master node is BlockProducer then send whole block date to storage node
	//otherwise send hash of block
	if (isBlockProducer()) {		
		std::string s(block.toJSONString());
		std::string sig = createX509Signature(block.getHash(), nodeIdentity);
		getBlockStorageNode();
		if (blockStorageNode.empty())
			return;
		logDebug("Sending block to storage node: %s, block number: %s", blockStorageNode.c_str(), std::to_string(block.getNumber()).c_str());
		gossip(blockStorageNode, CommandType::closeBlock, { {"b", base64_encodeString(s)}, {"si", sig}, {"key", base64encodedKey} });
		size_t blockNumber = block.getNumber();
		blocks.insert(BlocksMap::value_type(blockNumber, std::move(block)));
	} else {
		if (blocks.size() > 200) {
			blocks.clear();
			BlocksMap().swap(blocks);
		}
		size_t blockNumber = block.getNumber();
		blocks.insert(BlocksMap::value_type(blockNumber, std::move(block)));
	}
}

bool processCodePacket(const std::string& utxid, const std::string& htxid, const std::string& tenantId, const std::string& code, const std::string& inputs, const std::string& base64signature, const std::string& base64publicKey) {
	std::string message = std::string("c:") + std::to_string(static_cast<uint8_t>(CommandType::exeFunction)) + "|txid:" + utxid + "|k:" + base64publicKey + "|tid:" + tenantId + "|h:" + code + "|i:" + inputs;
#if PERFORM_SIG_VERIFICATION
	if (!verifyEd25519Signature(message, base64publicKey, base64signature)){
			logWarning("Signature verification failed");
			return false;
		}
#endif
	// If this Master Node is not a Master Node, it shouldn't be sending txNotifications.
	if (!subscribedTo21) {
		json j;
		j["error"] = "Sorry,You are hitting a Master Node that is not in m21; please hit the right one";
		j["txid"] = htxid;
		wsServer.send(base64publicKey, j.dump());
		return false;
	}
	std::string txId(getGUID(32));	
	// Since the client connected to us directly, we will make our own timestamp for this transaction.
	// Also, the verifier that this node selects is the compute node for this transaction.
	// Each verifier is listening on its own channel denoted by the public key of the verifier.
	logDebug("Building tx with ID " + txId);
	Transaction transaction(txId, currentTimestamp);
	// Since this is a new request, the current Master Node is the one handling it.
	transaction.setMasterNodeId(dhtNode.getId().toString());
	transaction.setTenantId(tenantId);
	transaction.setFunctionId(code);
	transaction.setSignature(base64signature);
	transaction.setPublicKey(base64publicKey);
	transaction.setInput(inputs);
	std::pair<TransactionsMap::iterator, bool> result;
	{
		std::lock_guard<std::mutex> lock(transactionsMutex);
		logDebug("Inserting " + txId + " into transactions");
		result = transactions.insert(TransactionsMap::value_type(txId, std::move(transaction)));
		logDebug("Insertion of id " + txId + " said " + std::to_string(result.second));
	}
	// Send the message off to the Compute Node. We add com=1 to notify the verifier to enter the Compute Node state. This is done because tx.isComputeNode is true.
	logDebug("done. sending to verifier");
	Transaction& tx = result.first->second;
	// Send this transaction to 20 other Master Nodes.	
		gossip("master21", CommandType::txNotification, { {"utxid", htxid}, {"tx", tx.toJson().dump() } });
	sendToVerifier(tx);
	return true;
}

void registerVote(std::string&& signature, std::string&& publicKey) {
	if (!canParticipateInVoting()) {
		logWarning("dropping vote from the key: " + publicKey);
		return;
	}
	publicKey = base64_decode(publicKey);
	//signature = decompressString(base64_decode(signature));
	size_t n = 0;
	{
		std::lock_guard<std::mutex> lock(randomNumbersMutex);
		for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
			if (*it == publicKey)
				return;
		}
		n = randomNumbers.size();
	} // We exit the critical section prematurely since verification might be expensive, and we don't want to lock the vector during verification. So we'll check for existence further down, again.
	Voter voter;
	dht::Blob bk(publicKey.begin(), publicKey.end());
	dht::crypto::PublicKey key(bk);
	// The signature should have been generated from the next voting timestamp, so we'll use this as the message.
	if (verifyX509Signature(nextVotingTimestampStr, signature, key)) {
		uint32_t number = 0;
		// The respective node's number will be the sum of the characters in their signature.
		size_t n = signature.length();
		for (int i = 0; i < n; i++)
			number += signature[i];
		voter = Voter(signature, publicKey, number, true);
		// In the time it took to generate a signature, this voter could have been added.
		{
			std::lock_guard<std::mutex> lock(randomNumbersMutex);
			if (n != randomNumbers.size()) { // Only search if someone else was added first.
				for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
					if (*it == publicKey)
						return;
				}
			}
			randomNumbers.push_back(std::move(voter));
		}
	} else {
		logWarning("Voting:- Signature verification failed " + publicKey);
	}
	logInfo(std::string("Received ") + std::to_string(randomNumbers.size()) + " votes");
}

void processIncomingTransaction(const std::string& utxid, const std::string& data) {
	json j = json::parse(data);
	std::string txId(j["txid"].get<std::string>());
	logDebug("Received new tx from other master21 node: %s", txId.c_str());
	// If a verifier told this Master Node about this transaction before the originating Master Node did,
	// this transaction will already exist, so just update it.
	std::unique_lock<std::mutex> lock(transactionsMutex);
	TransactionsMap::iterator it = transactions.find(txId);
	if (it != transactions.end()) {
		it->second.fromJson(j);
	} else { // Create the new transaction.
		Transaction tx;
		tx.fromJson(j);
		transactions.insert(TransactionsMap::value_type(txId, std::move(tx)));
	}
	it = transactions.find(txId);
	Transaction& transaction = it->second;
	sendToVerifier(transaction);
	// If this transaction is already verified except for receiving the txNotification, we need to trigger a verification event here.
	checkVerification(transaction);
	lock.unlock();
	std::string key = j["k"].get<std::string>();
}

void sendToVerifier(Transaction& tx) {
	std::string verifierKey;
	{
		std::lock_guard<std::mutex> lock(nodesSyncMutex);
		if (getNumberOfVerifiers() < 1) {
			logFatal("No verifiers available.");
			return;
		}
		verifierKey = getVerifierNodeKey(generateRandomNumber(0, static_cast<uint32_t>(getNumberOfVerifiers())));
	}
	if (tx.isComputeNode())
		tx.setComputeNodeId(verifierKey);
	getStateChangeStorageNode();
	if (stateChangeStorageNode.empty())
		return;
	gossip(verifierKey, CommandType::codeDelivery, { { "i", tx.getInput() }, { "co", tx.getFunctionId() },{ "txid", tx.getTxId() }, { "s", stateChangeStorageNode }, { "tid", tx.getTenantId() }, { "com", (tx.isComputeNode()) ? "0" : "1" } });
}

void getStateChangeStorageNode() {
	if (stateChangeStorageNode.empty()) {
		{
			std::lock_guard<std::mutex> lock(nodesSyncMutex);
			if (getNumberOfStorageNodes() < 2) {
				logFatal("Not enough storage nodes available; must have at least two.");
				return;
			}
		}
		stateChangeStorageNode = dhtGet("sn_state_change_key");
		if (stateChangeStorageNode.empty()) {
			{
				std::lock_guard<std::mutex> lock(nodesSyncMutex);
				stateChangeStorageNode = getStorageNodeKey(1);
			}
			dhtPut("sn_state_change_key", stateChangeStorageNode);
		}
	}
}

void sendConnectionRequest(int port) {
	FieldValueMap theFields;
	char cmdstr[5];
	sprintf(cmdstr, "%d", static_cast<uint8_t>(BlockChainNode::NodeType::masterNode));
	theFields.insert(FieldValueMap::value_type(std::string("t"), std::string(cmdstr)));
	std::string ip(getPublicIP());
	boost::trim(ip);
	theFields.insert(FieldValueMap::value_type(std::string("u"), std::string("ws://" + ip + std::string(":") + std::to_string(port))));
	gossip("masternodes", CommandType::connectionRequest, theFields);
}

void syncNodes(std::string& data) {
	json j = json::parse(data);
	std::string m = j["m"];
	std::string v = j["v"];
	std::string s = j["s"];

	json mj = json::parse(m);
	json vj = json::parse(v);
	json sj = json::parse(s);
	std::lock_guard<std::mutex> lock(nodesSyncMutex);
	NodesMap& masterNodes = getMasterNodes();
	for (auto it : mj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		masterNodes.insert(NodesMap::value_type(it.key(), BlockChainNode(j["k"], j["u"], nt)));
	}

	NodesMap& verifierNodes = getVerifierNodes();
	for (auto it : vj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		verifierNodes.insert(NodesMap::value_type(it.key(), BlockChainNode(j["k"], j["u"], nt)));
		addVerifierKey(std::string(it.key()));
	}

	NodesMap& storageNodes = getStorageNodes();
	for (auto it : sj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		storageNodes.insert(NodesMap::value_type(it.key(), BlockChainNode(j["k"], j["u"], nt)));
		addStorageKey(std::string(it.key()));
	}
}

void initializeNextVotingTimestamp() {
	time_t secondsUntilNextHour = 3600 - getSecondsPastHour();
	nextVotingTimestampStr = std::to_string(currentTimestamp + secondsUntilNextHour - ((60 - openVotingStartMinute) * 60));
}

void updateNextVotingTimestamp() {
	time_t lastVotingTimestamp = std::stoull(nextVotingTimestampStr);
	lastVotingTimestamp += 3600;
	nextVotingTimestampStr = std::to_string(lastVotingTimestamp);
}

bool canParticipateInVoting() {
	return !ignoreThisVotingRound;
}

void verifyTransaction(const std::string& txId, const std::string& hash, const std::string & output) {
	std::lock_guard<std::mutex> lock(transactionsMutex);
	if (transactions.find(txId) == transactions.end()) {
		// If a Master Node receives verificationResult before the TXNotification command,
		// this transaction will not exist yet. So, we should build it with what we have and then when
		// txNotification is received, the rest of the transaction will get filled in.
		// We should set the current time on the transaction so that it doesn't have a stamp of 0 and the cleanup routine doesn't prematurely get rid of it.
		Transaction tx(txId, hash, currentTimestamp);
		transactions.insert(TransactionsMap::value_type(txId, std::move(tx)));
	}
	Transaction& tx = transactions.at(txId);
	if (!output.empty())
		tx.setOutput(output);
	tx.verifyHash(hash); // Will update totalVerified if passes
	checkVerification(tx);
}

void checkVerification(Transaction& tx) {
	logDebug("verification Result : " + tx.getTxId() + "Compute node responded: " + std::to_string(tx.receivedOutput()) + " Received full transaction" + std::to_string(tx.receivedFullTransaction()));
	if (tx.isVerified()) {
		logDebug("+MAJORITY_THRESHOLD Success : " + tx.getTxId());
		// If this Master Node is the one that spawned the Compute Node for this transaction, it will also be
		// the one to tell the Compute Node to commit the transaction.
		// It will also be the one to send the result of the code's execution back to the client.
		// For a transaction to be fulfilled, this Master Node must have contact with the client and the function output must have been received. This transaction must also have not been sent to the client yet.
		if (tx.canSend()) {
			logDebug("canSend is true: so the response will be sent to the client from this node");
			json j;
			j["txid"] = tx.getTxId();
			getStateChangeStorageNode();
			if (stateChangeStorageNode.empty())
				j["w"] = "Warning: No storage nodes available to commit the state change update for this transaction. This could be because the storage nodes have disconnected from the network.";
			j["data"] = tx.getOutput();
			logDebug("+User Response : " + j.dump());
			wsServer.send(tx.getPublicKey(), j.dump());
			// Next, set sentToClient so if we receive another confirmation, we don't send a double response to the client.
			tx.setSentToClient();
			if (!stateChangeStorageNode.empty())
				gossip(tx.getComputeNodeId(), CommandType::canCommit, { { "txid", tx.getTxId() }, { "sid", stateChangeStorageNode}, { "tid", "" } });
		}
		if (!tx.inBlock()) {
			queueOut.push_back(tx);
			// Set inBlock so we don't add this transaction twice.
			tx.setInBlock();
		}
	}
}

void cleanupTransactionsMap() {
	std::lock_guard<std::mutex> lock(transactionsMutex);
	bool madeChanges = false;
	TransactionsMap::iterator it = transactions.begin();
	time_t oldTimestamp = currentTimestamp - 60;
	while (it != transactions.end()) {
		if (oldTimestamp > it->second.getTimeStamp()) {
			logDebug("Deleting transaction %s", it->second.getTxId());
			it = transactions.erase(it);
			madeChanges = true;
		} else
			it++;
	}
	// Next, deallocate memory held by the map so that it only contains the not deleted elements
	// We do this by creating a new map and swapping its memory with the transactions map.
	if (madeChanges)
		TransactionsMap(transactions.begin(), transactions.end()).swap(transactions);
}

void getBlockStorageNode() {
	if (blockStorageNode.empty()) {
		{
			std::lock_guard<std::mutex> lock(nodesSyncMutex);
			if (getNumberOfStorageNodes() < 1) {
				return;
			}
		}
		blockStorageNode = dhtGet("sn_block_close_key");
		if (blockStorageNode.empty()) {
			{
				std::lock_guard<std::mutex> lock(nodesSyncMutex);
				blockStorageNode = getStorageNodeKey(0);
			}
			dhtPut("sn_block_close_key", blockStorageNode);
		}
	}
}