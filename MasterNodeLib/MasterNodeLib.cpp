#include "masterNodeLib.h"
std::unordered_map<std::string, std::vector<std::string>> electedMasterNodes; // Keeps track of which master nodes were elected for which timestamps. For bookkeeping only.
std::string nextVotingTimestampStr; // Used to hold the epoch at which the next voting round will begin. Master nodes should sign this string.
bool ignoreThisVotingRound;
time_t openVotingStartMinute = 35;
TransactionsMap transactions;
BlocksMap blocks;
std::vector<Voter> randomNumbers; // Used to store random numbers generated by master nodes in new voting process.
std::vector<Voter> blockProducers; // The nodes that are eligible to be block producers in this round, sorted.
std::vector<Transaction> queueOut; // Used to store the transactions that should be committed to the next block.
bool inVotingPhase; // True if voting has begun.
Voter chosenNumber; // A struct to hold the random number generated by this node at the start of a new voting phase, based on the signature of the voting timestamp.
WebSocketServer* wsServer = nullptr;
dht::DhtRunner* dhtNode = nullptr;
SubscriptionAttributes* master21 = nullptr; // The channel that the 21 master nodes will listen on
SubscriptionAttributes* globalMasterNodeChannel = nullptr; // All master nodes listen on a common channel. This struct defines the channel.
SubscriptionAttributes* IndividualChannel = nullptr; // The individual master node's channel, defined by the master node's public key.
dht::crypto::Identity* nodeIdentity = nullptr;
time_t lastRoundTimestamp;
std::mutex transactionsMutex;
std::mutex randomNumbersMutex;
std::mutex nodesSyncMutex;
void runLoop() {
	while (true) {
		updateCurrentTimestamp();
		enterAndExitVotingPhase();
		time_t timeSinceLastRound = getCurrentTimestamp() - lastRoundTimestamp;
		if (timeSinceLastRound >= 1) {
			timeToCloseBlock();
			lastRoundTimestamp = getCurrentTimestamp();
		}
		std::this_thread::sleep_for(std::chrono::nanoseconds(1));
	}
}

uint8_t generateSecureRandomDigit(bool includeZero) {
	// If this is the first digit, we shouldn't include 0 or boost::multiprecision will fail to create an integer.
	NumberDistribution distribution((includeZero) ? '0' : '1', '9');
	RandomNumberGenerator generator{ dht::crypto::random_device{}() };
	Generator numberGenerator(generator, distribution);
	return static_cast<uint8_t>(numberGenerator());
}

int getBlockProducerFor(time_t timestamp) {
	if (blockProducers.size() < 1)
		return -1;
	return static_cast<int>(getSecondsPastHour(timestamp) % blockProducers.size());
}

int getCurrentBlockProducer() {
	if (blockProducers.size() < 1)
		return -1;
	return static_cast<int>(getSecondsPastHour() % blockProducers.size());
}

bool isBlockProducer() {
	int currentBlockProducer = getCurrentBlockProducer(); // Returns -1 if no block producers are available.
	if (currentBlockProducer < 0)
		return false;
	return blockProducers.at(currentBlockProducer).publicKey == dhtNode->getId().toString();
}

bool inVotingTime() {
	time_t minutes = getSecondsPastHour() / 60;
	return minutes >= openVotingStartMinute;
}

void enterAndExitVotingPhase() {
	if (inVotingTime()) {
		if (!inVotingPhase) { // This is the first time we've entered this voting phase.
			inVotingPhase = true;
			std::cout << "Voting now open" << std::endl;
			if (canParticipateInVoting()) {
				std::string signature(createX509Signature(nextVotingTimestampStr, nodeIdentity));
				uint32_t number = 0;
				size_t n = signature.length();
				for (int i = 0; i < n; i++)
					number += signature[i];
				chosenNumber = Voter(signature, dhtNode->getId().toString(), number, true);
				{
					std::lock_guard<std::mutex> lock(randomNumbersMutex);
					randomNumbers.push_back(chosenNumber);
				}
				gossip(dhtNode, "masternodes", CommandType::choseRandomNumber, { {"s", signature}, {"key", nodeIdentity->first->getPublicKey().toString()} });
			}
		}
	} else { // If the voting interval has expired
		if (inVotingPhase) {
			std::cout << "Voting now closed" << std::endl;
			// The first thing we do is set inVotingPhase to false to prevent anyone else from casting ballots to this node while we process everything.
			inVotingPhase = false;
			// Set the next voting timestamp to the minute mark in the hour when voting will start.
			updateNextVotingTimestamp();
			blockProducers.clear();
			// Next, the 21 lowest random numbers will be master nodes 0 to 20. We'll start with the block producer being position 0.
			bool nodeInList = false;
			// randomNumbers could be 0 if this node was not allowed to participate in this round of voting due to canParticipateInVoting.
			if (randomNumbers.size() > 0) {
				std::sort(randomNumbers.begin(), randomNumbers.end(), [](const Voter&a, const Voter&b) {
					return a < b;
				});
				for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
					if (it->valid) { // If we computed a valid number on this Voter
						if (it->publicKey == dhtNode->getId().toString())
							nodeInList = true;
						blockProducers.push_back(Voter(*it));
					}
					if (blockProducers.size() == TOTAL_MASTER_NODES)
						break;
				}
				randomNumbers.clear();
				randomNumbers.shrink_to_fit(); // Deallocate memory since we won't need it for another hour.
				electedMasterNodes[nextVotingTimestampStr] = std::vector<std::string>();
				for (std::vector<Voter>::iterator it = blockProducers.begin(); it != blockProducers.end(); it++)
					electedMasterNodes[nextVotingTimestampStr].push_back(it->publicKey);
				json j = electedMasterNodes;
				const char* jsonDump = j.dump().c_str();
				std::ofstream outFile("masternodes.dat", std::ios::out | std::ios::binary);
				outFile.write(jsonDump, strlen(jsonDump));
				outFile.close();
			} // If there were voters in this round.
			if (nodeInList) {
				if (master21 == nullptr) {
					// If this master node is not on the master21 channel already, meaning that before this round they were not among the 21.
					// Listen on the channel reserved for the 21 master nodes.
					std::cout << "Subscribed to 21" << std::endl;
					master21 = subscribeTo(dhtNode, "master21");
				}
			} else { // If node not in list
				if (master21 != nullptr) { // If this master node is subscribed.
					std::cout << "Unsubscribed from 21" << std::endl;
					unsubscribeFrom(dhtNode, master21);
					master21 = nullptr;
				}
			} // If !nodeInList
			// The ignore flag should have affect for one interval only. Now that this interval has elapsed, this node is allowed to vote in the upcoming interval.
			ignoreThisVotingRound = false;
		} // If inVotingPhase
	} // If !inVotingTime
}

bool compareTransactions(const Transaction& lhs, const Transaction& rhs) {
	return lhs.getTimeStamp() < rhs.getTimeStamp();
}

void timeToCloseBlock() {
	// The list of transactions to commit to the block is stored in queueOut.
	// A random storage node will commit the transactions to the block.
	time_t currentEpoch = std::time(0);
	std::lock_guard<std::mutex> lock(nodesSyncMutex);
	if (getNumberOfStorageNodes() < 1) {
		std::cerr << "No storage node found!" << std::endl;;
		return;
	}
	std::string key(getStorageNodeKey(generateRandomNumber(0, static_cast<uint32_t>(getNumberOfStorageNodes()))));

	std::vector<Transaction> tempvect;
	// QueueOut is modified when a transaction reaches verification, and
	// timeToCloseBlock runs on the main loop. So we need to protect this resource.
	{ // Critical section
		std::lock_guard<std::mutex> lock(transactionsMutex);
		std::sort(queueOut.begin(), queueOut.end(), compareTransactions); // Sort the transactions by timestamp.

		//compare transaction time with current time
		//if any transaction time is exceed than current time keep those transaction in queueOut
		std::vector<Transaction>::iterator it = queueOut.begin();
		std::time_t current_time = std::time(nullptr);
		while (it != queueOut.end()) {
			if (it->getTimeStamp() <= current_time) {
				tempvect.push_back(*it);
				it = queueOut.erase(it);
			} else {
				break;
			}
		}
	}
	//create block by passing list of transactions msg
	BlockUtil blockUtil(dhtNode);
	Block block = blockUtil.getBlock(tempvect);
	tempvect.clear();
	//if master node is BlockProducer than send hole block date to storage node
	//otherwise send hash of block
	if (isBlockProducer()) {
		std::string s(block.toJSONString());
		std::vector<uint8_t> vec(s.begin(), s.end());
		dht::Blob b(vec);
		std::string sig = createX509Signature(block.getHash(), nodeIdentity);

		gossip(dhtNode, key, CommandType::closeBlock, { {"b", base64_encode(b)}, {"si", sig}, {"key", nodeIdentity->first->getPublicKey().toString()} });
	} else {
		blocks.insert(BlocksMap::value_type(block.getNumber(), std::move(block)));
	}
}

bool processCodePacket(const std::string& tenantId, const std::string& code, const std::string& inputs, const std::string& base64signature, const std::string& base64publicKey) {
	std::string message = std::string("c:") + std::to_string(static_cast<uint8_t>(CommandType::exeFunction)) + "|tid:" + tenantId + "|h:" + code + "|i:" + inputs;
	if (!verifyEd25519Signature(message, base64publicKey, base64signature))
		return false;
	std::string txId(getGUID(32));

	// Since the client connected to us directly, we will make our own timestamp for this transaction.
	// Also, the verifier that this node selects is the compute node for this transaction.
	time_t timestamp = getCurrentTimestamp();
	// Each verifier is listening on its own channel denoted by the public key of the verifier.
	Transaction transaction(txId, timestamp, true);
	// Since this is a new request, the current Master Node is the one handling it.
	transaction.setMasterNodeId(dhtNode->getId().toString());
	transaction.setTenantId(tenantId);
	transaction.setCode(code); // This code will be changed to deterministic code when the Compute Node responds.
	transaction.setSignature(base64signature);
	transaction.setPublicKey(base64publicKey);
	transaction.setInput(inputs);
	// Send the message off to the Compute Node. We add com=1 to notify the verifier to enter the Compute Node state. This is done because tx.isComputeNode is true.
	sendToVerifier(transaction);
	// Send this transaction to 20 other Master Nodes.
	// If this Master Node is not a Master Node, it shouldn't be sending txNotifications.
	if (master21 != nullptr)
		gossip(dhtNode, "master21", CommandType::txNotification, { {"tx", transaction.toJson().dump() } });
	std::lock_guard<std::mutex> lock(transactionsMutex);
	transactions.insert(TransactionsMap::value_type(txId, std::move(transaction)));
	return true;
}

void registerVote(std::string&& signature, std::string&& publicKey) {
	if (!canParticipateInVoting())
		return;
	size_t n = 0;
	{
		std::lock_guard<std::mutex> lock(randomNumbersMutex);
		for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
			if (*it == publicKey)
				return;
		}
		n = randomNumbers.size();
	} // We exit the critical section prematurely since verification might be expensive, and we don't want to lock the vector during verification. So we'll check for existence further down, again.
	Voter voter;
	dht::Blob bk(publicKey.begin(), publicKey.end());
	dht::crypto::PublicKey key(bk);
	// The signature should have been generated from the next voting timestamp, so we'll use this as the message.
	if (verifyX509Signature(nextVotingTimestampStr, signature, key)) {
		uint32_t number = 0;
		// The respective node's number will be the sum of the characters in their signature.
		size_t n = signature.length();
		for (int i = 0; i < n; i++)
			number += signature[i];
		voter = Voter(signature, publicKey, number, true);
		// In the time it took to generate a signature, this voter could have been added.
		{
			std::lock_guard<std::mutex> lock(randomNumbersMutex);
			if (!inVotingPhase) // This node cast a vote right when the interval closed, so by the time they got verified, the interval elapsed.
				return;
			if (n != randomNumbers.size()) { // Only search if someone else was added first.
				for (std::vector<Voter>::iterator it = randomNumbers.begin(); it != randomNumbers.end(); it++) {
					if (*it == publicKey)
						return;
				}
			}
			randomNumbers.push_back(std::move(voter));
		}
	}
	std::cout << "Received " << randomNumbers.size() << " votes" << std::endl;
}

void processIncomingTransaction(std::string& data) {
	json j = json::parse(data);
	std::string txId(j["txid"].get<std::string>());
	// If a verifier told this Master Node about this transaction before the originating Master Node did,
	// this transaction will already exist, so just update it.
	std::lock_guard<std::mutex> lock(transactionsMutex);
	TransactionsMap::iterator it = transactions.find(txId);
	if (it != transactions.end()) {
		it->second.fromJson(j);
		sendToVerifier(it->second);
	} else { // Create the new transaction.
		Transaction tx;
		tx.fromJson(j);
		sendToVerifier(tx);
		transactions.insert(TransactionsMap::value_type(txId, std::move(tx)));
	}
}

void sendToVerifier(Transaction& tx) {
	if (getNumberOfVerifiers() < 1) {
		std::cerr << "No verifiers available." << std::endl;
		return;
	}
	std::string verifierKey(getVerifierNodeKey(generateRandomNumber(0, static_cast<uint32_t>(getNumberOfVerifiers()))));
	if (tx.isComputeNode())
		tx.setComputeNodeId(verifierKey);
	if (getNumberOfStorageNodes() < 1) {
		std::cerr << "No storage nodes available." << std::endl;
		return;
	}
	std::string key(getStorageNodeKey(generateRandomNumber(0, static_cast<uint32_t>(getNumberOfStorageNodes()))));
	gossip(dhtNode, verifierKey, CommandType::codeDelivery, { { "i", tx.getInput() }, { "co", tx.getCode() },{ "txid", tx.getTxId() }, { "s", key }, { "tid", tx.getTenantId() }, { "com", (tx.isComputeNode()) ? "0" : "1" } });
}

void sendConnectionRequest(int port) {
	FieldValueMap theFields;
	char cmdstr[5];
	sprintf(cmdstr, "%d", static_cast<uint8_t>(BlockChainNode::NodeType::masterNode));
	theFields.insert(FieldValueMap::value_type(std::string("t"), std::string(cmdstr)));
	// uri of the storage node
	std::string ip(getPublicIP());
	boost::trim(ip);
	// uri of the verifierNode
	theFields.insert(FieldValueMap::value_type(std::string("u"), std::string("ws://" + ip + std::string(":") + std::to_string(port))));
	//gossip verifierNode info to all mater nodes
	gossip(dhtNode, "masternodes", CommandType::connectionRequest, theFields);
}

void syncNodes(std::string& data) {
	json j = json::parse(data);
	std::string m = j["m"];
	std::string v = j["v"];
	std::string s = j["s"];

	json mj = json::parse(m);
	json vj = json::parse(v);
	json sj = json::parse(s);
	std::lock_guard<std::mutex> lock(nodesSyncMutex);
	NodesMap* masterNodes= getMasterNodes();
	for (auto it : mj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		masterNodes->insert(NodesMap::value_type(it.key(), new BlockChainNode(j["k"], j["u"], nt)));
	}

	NodesMap* verifierNodes = getVerifierNodes();
	for (auto it : vj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		verifierNodes->insert(NodesMap::value_type(it.key(), new BlockChainNode(j["k"], j["u"], nt)));
		addVerifierKey(std::string(it.key()));
	}

	NodesMap* storageNodes = getStorageNodes();
	for (auto it : sj.items()) {
		json j = json::parse(it.value().get<std::string>());
		BlockChainNode::NodeType nt = static_cast<BlockChainNode::NodeType>(j["t"]);
		storageNodes->insert(NodesMap::value_type(it.key(), new BlockChainNode(j["k"], j["u"], nt)));
		addStorageKey(std::string(it.key()));
	}
}

void updateNextVotingTimestamp() {
	time_t secondsUntilNextHour = 3600 - getSecondsPastHour();
	nextVotingTimestampStr = std::to_string(getCurrentTimestamp() + secondsUntilNextHour - ((60 - openVotingStartMinute) * 60));
}

bool canParticipateInVoting() {
	return !ignoreThisVotingRound && inVotingPhase;
}