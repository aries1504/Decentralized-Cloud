#pragma once
// Disable the buffer overflow warning, since we're internally checking for it.
#pragma warning (disable: 4996)
#include <exception>
#include <vector>
#include <functional>
#include <unordered_map>
#include <mutex>
#include <boost/random/random_device.hpp>
#include <boost/algorithm/string/join.hpp>
#include <common/transaction.h>
#include <common/functions.h>
#include "BlockUtil.h"
#define PERFORM_SIG_VERIFICATION 1

typedef std::map< std::string, Transaction> TransactionsMap; // Mapping of txId..Transaction
typedef std::map<size_t, BlockUtil::Block> BlocksMap; // Mapping of blockId..Block
typedef std::map<std::string, std::string> TxAndConnectionMap;

class Voter {
public:
	std::string signature;
	std::string publicKey;
	uint32_t number;
	bool valid;

	Voter() {}

	Voter(const std::string signature, const std::string publicKey, const uint32_t number, const bool valid) {
		this->signature = signature;
		this->publicKey = publicKey;
		this->number = number;
		this->valid = valid;
	}

	bool operator < (const Voter& b) const {
		return number < b.number;
	}

	bool operator <= (const Voter& b) const {
		return number <= b.number;
	}

	bool operator == (const Voter& b) const {
		return number == b.number;
	}

	bool operator == (const std::string& b) const {
		return publicKey == b;
	}
};

extern std::unordered_map<std::string, std::vector<std::string>> electedMasterNodes; // Keeps track of which master nodes were elected for which timestamps. For bookkeeping only.
extern std::string nextVotingTimestampStr; // Used to hold the epoch at which the next voting round will begin. Master nodes should sign this string.
extern bool ignoreThisVotingRound; // If true, the current or immediate open voting interval will be ignored. This flag resets to false once the open voting interval closes and
// is meant to prevent Master Nodes from entering the open voting interval immediately upon boot, since their joining the open voting interval late could result in incorrect data.
extern time_t openVotingStartMinute; // The minute past the hour that open voting begins. If the time is from this minute up to the next hour, open voting is in place.
extern TransactionsMap transactions;
extern BlocksMap blocks;
extern std::vector<Voter> randomNumbers; // Used to store random numbers generated by master nodes in new voting process.
extern std::vector<Voter> blockProducers; // The nodes that are eligible to be block producers in this round, sorted.
extern std::vector<Transaction> queueOut; // Used to store the transactions that should be committed to the next block.
extern bool inVotingPhase; // True if voting has begun.
extern Voter chosenNumber; // A struct to hold the random number generated by this node at the start of a new voting phase, based on the signature of the voting timestamp.
extern WebSocketServer wsServer;
extern SUB_TYPE master21; // The channel that the 21 master nodes will listen on
extern SUB_TYPE globalMasterNodeChannel; // All master nodes listen on a common channel.
extern SUB_TYPE IndividualChannel; // The individual master node's channel, defined by the master node's public key.
extern dht::crypto::Identity* nodeIdentity;
extern time_t lastRoundTimestamp;
extern time_t lastCleanupTime;
extern std::mutex transactionsMutex;
extern std::mutex randomNumbersMutex; // Used to lock the vector that voters are put into before open voting closes.
extern std::atomic<bool> requestedMasterNodeStop; // This flag will be set to true when the program is in the exit handler, and will terminate the master node loop safely.
// It should be called before the global exit handler and runningMasterNode should be waited on before calling the global exit handler. In this way, we ensure thread safety and won't get undefined behavior as resources are cleaned up.
extern std::atomic<bool> runningMasterNode; // True if the master node's main loop is running, false if the loop has either been terminated or has not started yet.
extern std::mutex blockDetailRequestsMutex;
extern TxAndConnectionMap blockDetailRequests;
extern std::mutex txDetailRequestsMutex;
extern TxAndConnectionMap txDetailRequests;
extern std::string blockStorageNode; // The designated storage node for block commits
extern bool subscribedTo21; // True if this master node is on the m21 channel, false otherwise.
// Fired when the message received contains code that needs to be executed. The client will send all the information listed in the parameters. Returns true on success, false on failure.
// The function will fail in these cases: signature validation fails, sending of the generated transaction id back to the client failed.
bool processCodePacket(const std::string& utxid, const std::string& htxid, const std::string& tenantId, const std::string& code, const std::string& inputs, const std::string& signature, const std::string& publicKey);
// Fired when the voting has begun.
void enterAndExitVotingPhase();
// Fired when a master node delivers a voting number. We use the move operator because these numbers are potentially very large.
void registerVote(std::string&& signature, std::string&& publicKey);
// When a certain amount of time has elapsed and the block is ready to close.
void timeToCloseBlock();
// Gets the block producer for a given timestamp. Returns -1 if no block producers are available.
int getBlockProducerFor(time_t timestamp);
// Gets the current block producer. Returns -1 if no block producers are available.
int getCurrentBlockProducer();
// True if this node is the current block producer.
bool isBlockProducer();
// Compares two transactions based on their timestamps; used for ordering in a vector.
bool compareTransactions(const Transaction& lhs, const Transaction& rhs);
// Processes a transaction notification
// utxid is a GUID provided by the client. This is NOT the transaction ID assigned to this transaction by the Master Node; instead, it is the ID supplied to the originating Master Node by the client connected over web socket.
// Data is the JSON representation of the transaction.
void processIncomingTransaction(const std::string& utxid, const std::string& data);
// Sends the code from the given transaction off to a verifier. If tx.isComputeNode is true, then com is set to 0, else it is set to 1. This is in accordance with nodeType::compute and nodeType::verifier. Sets computeNodeId if isComputeNode is true.
void sendToVerifier(Transaction& tx);
// Generates a cryptographically secure digit. If includeZero is true, the digit can be 0, else it will be from 1 to 9.
uint8_t generateSecureRandomDigit(bool includeZero);
// Determines if we're in the time interval when voting is allowed.
bool inVotingTime();
// Initializes the voting timestamp at which voting begins.
// After this, updateNextVotingTimestamp will simply fast-forward this timestamp value.
void initializeNextVotingTimestamp();
// Updates the timestamp at which voting begins by fast-forwarding the already-initialized voting timestamp. This is the string all master nodes will sign
void updateNextVotingTimestamp();
// Determines whether or not this Master Node is allowed to participate in the current open voting interval. This result must be true for
// the Master Node to both send its ballot to other nodes and to accept ballots from other nodes.
bool canParticipateInVoting();
// Runs the Master Node loop
void runLoop();
void sendConnectionRequest(int port);
// When a verificationResult comes back, this function is executed to update the transaction. It also handles delivering the result back to the client.
void verifyTransaction(const std::string& txId, const std::string& hash, const std::string & output);
// After verifyTransaction updates the transaction as needed, checkVerification is used to increment the verification count of the transaction and consider the transaction complete if it has been successfully verified.
// This function is thread-safe so it is not necessary to hold the transactions mutex.
void checkVerification(Transaction& tx);
// Retrieves the designated storage node where state change commands are stored. This function only hits the dht if it has not retrieved the storage node key before.
// the stateChangeStorageNode variable will be set to the empty string if there was a problem retrieving or initializing the key. If stateChangeStorageNode is empty after a call to this function, the caller should abort.
void getStateChangeStorageNode();
// Retrieves the designated storage node where blocks are stored. This function only hits the dht if it has not retrieved the storage node key before.
// the blockStorageNode variable will be set to the empty string if there was a problem retrieving or initializing the key. If blockStorageNode is empty after a call to this function, the caller should abort.
void getBlockStorageNode();
// Cleans up old transactions so they don't remain in memory forever.
// Because we don't know when verification results will arrive, we can't expect
// txNotification or verificationResult handlers to clean up the transactions.
void cleanupTransactionsMap();