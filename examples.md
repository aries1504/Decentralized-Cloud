# Developer Documentation

Our block chain uses JavaScript for function execution. You can run functions with zero or more parameters, and we’ll show you how to do it. This page contains code examples as well as instructions on interacting with the state of the block chain.

## Setting Up

You will first need to create an account on the Block Chain Explorer. This account will be used to sign your transactions so that only you are allowed to execute functions through your account. An account consists of a public and private keypair, and you can generate these pieces of information by visiting explorer.sparkster.network and navigating to Account Creator. There, click “Create Account.”

You will see your public and private keys show up on the page. Keep your keys with you, as they represent your account on the network. You should treat your private key like a password; anyone who has access to your private key is able to impersonate your account.

## Deploying And Executing Code

Now that you have an account, you can begin to deploy and execute code on the block chain. For these sections, we assume a knowledge of JavaScript.

### Deploying function With No Parameters

We will begin by deploying and executing a function with no parameters. Let us create a function that returns a constant value to see it working.
```javascript
Function returnConstant() { return 1; } 
```
- From the Explorer, click Code Deployer.
- Enter the shown function inside the code box.
- Enter your public and private keys as previously generated by the network.
- Click Deploy.
- Wait for the network to respond. You will get a function ID in response. This means your code has successfully deployed and can now be run. Save this ID; we’ll need it in the next section.

### Executing The Code

Since we’ve deployed code on the network and  now have a function ID, we can proceed to execute this code.
- From the explorer, click Code Executor.
- Enter the function ID as previously provided to you by the network.
- Leave the Parameters field blank for now.
- Enter your public and private keys as provided to you by the network.
- Click Execute. You’ll be given a transaction hash which is a unique identifier that follows your code execution through the network. Eventually, you’ll see the result `1` displayed in the results panel.

### Function With Multiple Parameters

You can execute functions with many parameters easily; here, we will show you how to do it. The good news is that the only thing that will change is what you enter into the Parameters box on the Code Executor. The actual function will look exactly like a standard JavaScript function. Let us deploy and execute the following function.
```javascript
function increment(x) {
	return x+1;
}
```
This function simply increments the value passed to it and returns the new value. We can deploy it just like we did in the last section, so we’ll go directly to the Code Executor page assuming that we have the ID of this function in hand.
- Enter the function ID that was given to you when you deployed this function.
- In the Parameters box, enter `{"x":5}`.
- Enter your public and private keys as previously given to you by the network.
- Click Execute.
- You will see the result of the function: `6`.

### Providing Parameters

Notice in the previous section we entered some JSON in the Parameters box on the Code Executor. This is how we pass parameters to the functions that accept them.

For those of you who are not familiar with JSON, it is written like this: `{"param1":param1_value, "param2":param2_value, ...}`

The `paramN_value` part can be any JavaScript type. For example, a string value would be represented as: `{"param1":"some string"}`.

If you wanted to pass an array, you can certainly do this.

### More Advanced Input: Arrays

First, let us write a JavaScript function that does something with arrays.
```javascript
function averageArray(numbers) {
	var n = numbers.length;
	var average = 0;
	for (var i = 0; i < n; i++)
		average += numbers[i];
	return average / n;
}
```
This function computes the average of an array of numbers. You can deploy it just like we’ve deployed our past functions. We’ll skip ahead to the Code Executor, assuming we have a function ID in hand for this function.
- Enter the function ID as provided by the network.
- In the Parameters box, enter: `{"numbers":[10, 20, 30]}`.
- Enter your public and private keys as previously given to you by the network.
- Click Execute.
- You’ll see the result 20 populate in the Results panel after you receive the transaction hash.

## Modifying State

There are two types of functions that can be executed on the Sparkster network. The first type is a rudimentary function. This type of function does not maintain state between executions. All of the functions we've written so far are rudimentary functions. For example, the average function does not maintain any type of memory about previously calculated averages.

The second type of function is a stateful function. This type of function maintains a "memory" of some state, and is able to draw on that memory every time it executes. It is also able to modify states of other objects. For example, a function that calculates the cumulative sum as data are emitted from a stream is a stateful function because it must maintain the last sum it calculated in order to add to that sum the next time it is called when a number is emitted from a stream.

Functions that modify globally accessible data are called "nonconstant" functions, and functions that make no modifications to the global state are called "constant" functions.

in the following sections, we will show you how to read from and modify the global state.

### Creating Objects

You can create both templates and documents on the block chain. A template is a blueprint of a document and a document is an actual instance of the template. In other words, a template is a schema and a document is an actual row in a table.

For any interaction with the global state, you use the `execute` function. The signature of this function is as follows:
```javascript
function execute(jsonStr, templateId, entityType, httpMethod);
```
If you want to create a template, your code will look something like the following:
```javascript
function makeTemplate() {
	var fields = ["name", "email"];
	var json = {collections:{servicedirectory:{rowset: fields}}};
	var jsonStr = JSON.stringify(json);
	execute(jsonStr, null, "template", "POST");
}
```

You'll get a response once your transaction is verified that will contain the ID of the template. Use this ID in the `TEMPLATE_ID` field below.
```
{"data":"Qmd2mUr3AD3znZz9ZAGwnEkY8MWL8wzsekrSavQhbDJ5VD","id":"yrrgqwdonwpxecmrscjeqnbkyhnlfsnmtsid","txid":"qihycbydgjxtrsuqdxzwkmusyeehwfoi"}
```

Next, if you wanted to create a document from your template, assuming you received the template ID above, you would use code similar to the following:
```javascript
function createDocument() {
	var fields = {name: "Sparky", email:"sparky@cool.com"};
	var json = {collections:{servicedirectory:{rowset:[fields]}}};
	var jsonStr = JSON.stringify(json);
	execute(jsonStr, "yrrgqwdonwpxecmrscjeqnbkyhnlfsnmtsid", "document", "POST");
}
```

As with creating a template, once your transaction is verified, you'll receive the ID of the document that you created on the network; if you want to make changes to this specific document, you'll need to save the document ID.

### Fetching, Updating And Deleting Documents

For a fetch, update or delete operation, you will need to provide a filter so the network knows what document you intend to fetch or modify.

#### Fetching Documents

We'll start with the simplest case: fetching a document. Here, your JSON should look like the following:
```
{
	collections: {
		servicedirectory: {
			rowset: [
				...
			],
			rowfilter: [
				...
			]
		}
	}
}
```
The `rowset` array is a list of strings containing field names to retrieve. For example, to retrieve only the `age` field, you would provide `rowset: ["age"]`.

The `rowfilter` array defines the expression you want to filter your query by, and is constructed as follows:
```
{
	logicaloperator: "",
	expressionbegin: "",
	attribute: "",
	operator: "",
	value: "",
	expressionend: ""
}
```
All fields are optional, so you can construct any expression you like.
- logicaloperator: If provided, should be set to one of "&&" or "||"
- expressionbegin: If provided, should be set to "("
- attribute: If provided, should be a field name. This field will be surrounded in quotation marks by the expression builder
- operator: If provided, should be one of "==", "<", "<=", ">", ">=", or "!="
- value: If provided, should contain the right-hand operand. This field will be surrounded in quotation marks by the expression builder
- expressionend: If provided, should be set to ")"

Example:
```
[
	{
		attribute: "name",
		operator: "==",
		value: "sparky"
	},
	{
		logicaloperator: "&&",
		attribute: "email",
		operator: "==",
		value: "sparky@cool.com"
	}
]
```
Resulting filter expression:
```javascript
"name" == "sparky" && "email" == "sparky@cool.com"
```
Note: the quotation marks around the field names and values are by design and cannot be removed.

Once we have our JSON, we can fetch a document by making a call to `execute` as follows:
```javascript
var result = execute(jsonStr, TEMPLATE_ID, "document", "GET");
```
Notice that we provide `"document"` here instead of `"template"`. This is because we are acting on documents at this point.

This is a synchronous function, and `result` will contain an array of the documents that were pulled from the network. Here is sample code to convert all email addresses to lower case:
```javascript
var result = execute(jsonStr, TEMPLATE_ID, "document", "GET");
var documents = JSON.parse(result); // The set of name and email documents
for (var i = 0, n = documents.length; i < n; i++) {
	documents[i].email = documents[i].email.toLowerCase();
}
```

#### Updating Documents

Aside from the `rowfilter` JSON, the supplied JSON should contain an object that defines the update. For example, if we wanted to change everyone's adult flag to `true` when their birth year was less than 2000 based on the year this document was written, we would construct JSON as follows:
```javascript
var json = {
	collections:{
		servicedirectory: {
			rowset:[{adult: true}],
			rowfilter:[{attribute: "birthyear", operator: "<", value: "1999"}]
		}
	}
};
```
Next, we would call the `execute` function as follows:
```javascript
execute(JSON.stringify(json), TEMPLATE_ID, "document", "PUT");
```
We use the `PUT` verb here in accordance with our cloud API.

You will receive a response as with the interactions we have already seen. The `data` field will contain the result of the update. In the case of a successful update, `data` will contain `"Documents are updated successfully"`.

#### Deleting Documents

Deleting a document is similar to fetching a document except that we provide the `DELETE` verb instead of the `GET` verb.
```javascript
var json = {
	collections: {
		servicedirectory: {
			rowfilter: [{attribute: "age", operator: ">=", value: "30"}]
		}
	}
};
execute(JSON.stringify(json), TEMPLATE_ID, "document", "DELETE");
```
This code will wipe out anyone whose age is greater than or equal to thirty years and is a good way to get rid of all of us old people.

### Creating Templates From The Explorer

An alternate way to create document templates is to use the Block Chain Explorer at explorer.sparkster.network. The results are the same as creating the template through code.